* 动态规划
** 矩形或抽象成矩形的动态规划
*** 72.字符A变换（增删改）最少的字符到字符B

#+begin_src sh :results output :wrap source markdown
cat problems/72.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定两个单词 _word1_ 和 _word2_，计算出将 _word1_ 转换成 _word2_ 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

1.  插入一个字符
2.  删除一个字符
3.  替换一个字符

,**示例 1:**

,**输入:** word1 = "horse", word2 = "ros"
,**输出:** 3
,**解释:** 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

,**示例 2:**

,**输入:** word1 = "intention", word2 = "execution"
,**输出:** 5
,**解释:** 
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u') 
[https://leetcode-cn.com/problems/edit-distance/description/]
#+end_source

**** 解法 1 

*状态定义*

dp[r][c]将字符A的1~r-1位变换为字符B的1~c-1位最少的步数

*状态转移方程*

dp[r][0] = r 将字符A第r-1位删光需要的步数

dp[0][c] = c 将字符B第c-1位删光需要的步数

dp[r][c] = min(dp[r-1][c-1], dp[r-1][c], dp[r][c-1]) + 1; 改、增、删 之前的最小 + 1步

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 1/,/^}/{/\@solution dp 1/!p}' solutions/72.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int minDistance(String word1, String word2) {
        int rl = word1.length(), cl = word2.length();
        int[][] dp = new int[rl + 1][cl + 1];
        for (int r = 0; r <= rl; r ++)
            dp[r][0] = r;
        for (int c = 0; c <= cl; c ++) 
            dp[0][c] = c;
        for (int r = 1; r <= rl; r ++) 
            for (int c = 1; c <= cl; c ++) 
                dp[r][c] = (word1.charAt(r - 1) == word2.charAt(c - 1)) 
                    ? dp[r - 1][c - 1] 
                    : Math.min(dp[r - 1][c - 1], Math.min(dp[r][c -1], dp[r - 1][c])) + 1;
        return dp[rl][cl];
    }    
}
#+end_source

**** 解法 2

压缩解法 1 的dp数组

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 2/,/^}/{/\@solution dp 2/!p}' solutions/72.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int minDistance(String word1, String word2) {
        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();
        int rl = w1.length, cl = w2.length;
        int[] dp = new int[cl + 1];
        for (int c = 0; c <= cl; c ++) 
            dp[c] = c;
        for (int r = 1; r <= rl; r ++) {
            int ul = dp[0]; // upper left
            for (int c = 0; c <= cl; c ++) {
                if (c == 0) {
                    dp[c] = r;
                    continue;
                }
                int up = dp[c], l = dp[c - 1]; // up and left
                dp[c] = (w1[r - 1] == w2[c - 1]) ? ul
                    : Math.min(ul, Math.min(up, l)) + 1;
                ul = up;
            }
        }
        return dp[cl];
    }
}
#+end_source


*** 85 二维数组中的最大矩形

#+begin_src sh :results output :wrap source markdown
cat problems/85.*.md
#+end_src

**** 解法 1
*状态定义*

dp[r][c] c之前连续为1的长度

*状态转移方程*

dp[r][c] = matrix[r][c] == 0 ? 0 : dp[r][c - 1] + 1;

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 1/,/^}/{/\@solution dp 1/!p}' solutions/85.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int maximalRectangle(char[][] matrix) { 
        if (matrix.length == 0) return 0;
        int rl = matrix.length, cl = matrix[0].length;
        int[][] dp = new int[rl][cl];
        int res = 0;
        for (int r = 0; r < rl; r ++) {
            for (int c = 0; c < cl; c ++) {        
                if (matrix[r][c] == '0') continue;
                dp[r][c] = (c == 0) ? 1 : dp[r][c - 1] + 1;
                int left = dp[r][c];
                for (int _r = r; _r >= 0; _r --) {
                    left = Math.min(left, dp[_r][c]);
                    res = Math.max(res, left * (r - _r + 1));
                }
            }
        }
        return res;
    }
}
#+end_source

**** 解法 2

*状态定义*

left[r][c]  matrix[r][c] 上方长方形的左边界

right[r][c] matrix[r][c] 上方长方形的右边界

up[r][c] matrix[r][c] 上方长方形的高

*状态转移方程*

if (matrix[r][c] == 1 )

left[r][c] = min(left[r - 1][c], 当前行的左边界)

right[r][c] = min(right[r - 1][c], 当前行的右边界)

up[r][c] = up[r - 1][c] + 1

if (matrix[r][c] == 0)

left[r][c] = 0

right[r][c] = cl - 1

up[r][c] = 0

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 2/,/^}/{/\@solution dp 2/!p}' solutions/85.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length == 0) return 0;
        int rl = matrix.length, cl = matrix[0].length;
        int[][] left = new int[rl][cl], right = new int[rl][cl], up = new int[rl][cl];
        int res = 0;
        for (int r = 0; r < rl; r ++) {
            int leftBorder = 0, rightBorder = cl - 1;
            for (int c = 0; c < cl; c ++) {
                if (matrix[r][c] == '1') {
                    up[r][c] = r > 0 ? up[r - 1][c] + 1: 1;
                    left[r][c] = r > 0 ? Math.max(left[r - 1][c], leftBorder) : leftBorder;
                } else {
                    up[r][c] = 0;
                    left[r][c] = 0;
                    leftBorder = c + 1;
                }
                int _c = cl - 1 - c;
                if (matrix[r][_c] == '1') {
                    right[r][_c] = r > 0 ? Math.min(right[r - 1][_c], rightBorder) : rightBorder;
                } else {
                    right[r][_c] = cl - 1;
                    rightBorder = _c - 1;
                }
            }
            for (int c = 0; c < cl; c ++) {
                res = Math.max(res, (right[r][c] - left[r][c] + 1) * up[r][c]);
            }
        }
        return res;
    }
}
#+end_source

**** 解法 3
压缩解法 2 的dp数组

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 3/,/^}/{/\@solution dp 3/!p}' solutions/85.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if (matrix.length == 0) return 0;
        int rl = matrix.length, cl = matrix[0].length;
        int[] left = new int[cl], right = new int[cl], up = new int[cl];
        Arrays.fill(right, cl - 1);
        int res = 0;
        for (int r = 0; r < rl; r ++) {
            int leftBorder = 0, rightBorder = cl - 1;
            for (int c = 0; c < cl; c ++) {
                if (matrix[r][c] == '1') {
                    up[c] = up[c] + 1;
                    left[c] = Math.max(left[c], leftBorder);
                } else {
                    up[c] = 0;
                    left[c] = 0;
                    leftBorder = c + 1;
                }
                int _c = cl - 1 - c;
                if (matrix[r][_c] == '1') {
                    right[_c] = Math.min(right[_c], rightBorder);
                } else {
                    right[_c] = cl - 1;
                    rightBorder = _c - 1;
                }
            }
            for (int c = 0; c < cl; c ++) {
                res = Math.max(res, (right[c] - left[c] + 1) * up[c]);
            }
        }
        return res;
    }
}
#+end_source


*** 115 不同的子序列

#+begin_src sh :results output :wrap source markdown
cat problems/115.*.md
#+end_src

**** 解法 1

*状态定义*

dp[r][c] t的前r个在s的前c个出现的个数

*状态转移方程*

s(col) = abab, t(row) = ab
1 1 1 1 1
0 1 1 2 2
0 0 1 1 3
ab,ab = a,ab + a,a
abab,ab = aba,ab + aba,a

if(t[r] == s[c]) dp[r][c] = dp[r][c - 1] + dp[r - 1][c - 1]
else             dp[r][c] = dp[r][c - 1]

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 1/,/^}/{/\@solution dp 1/!p}' solutions/115.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int numDistinct(String s, String t) {
        int rl = t.length(), cl = s.length();
        int[][] dp = new int[rl + 1][cl + 1];
        for (int c = 0; c < cl; c ++) 
            dp[0][c] = 1;
        
        for (int r = 1; r < rl + 1; r ++) 
            for (int c = 1; c < cl + 1; c ++) 
                if (t.charAt(r - 1) == s.charAt(c - 1))
                    dp[r][c] = dp[r - 1][c - 1] + dp[r][c - 1];
                else 
                    dp[r][c] = dp[r][c - 1];
            
        return dp[rl][cl];
    }
}
#+end_source

**** 解法 2

压缩解法 1 中的dp数组

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 2/,/^}/{/\@solution dp 2/!p}' solutions/115.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int numDistinct(String s, String t) {
        int rl = t.length(), cl = s.length();
        int[] dp = new int[cl + 1];
        Arrays.fill(dp, 1);
        for (int r = 1; r < rl + 1; r ++) {
            int prev = dp[0];
            dp[0] = 0;
            for (int c = 1; c < cl + 1; c ++) {
                int temp = dp[c];
                if (t.charAt(r - 1) == s.charAt(c - 1))
                    dp[c] = prev + dp[c - 1];
                else
                    dp[c] = dp[c - 1];
                prev = temp;
            }
        }
        return dp[cl];
    }
}
#+end_source


*** TODO 44

** 求组合总数的动态规划
*** 91.字母转数字后的编码能还原多少种可能性

#+begin_src sh :results output :wrap source markdown
cat problems/91.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

,**示例 1:**

,**输入:** "12"
,**输出:** 2
,**解释:** 它可以解码为 "AB"（1 2）或者 "L"（12）。

,**示例 2:**

,**输入:** "226"
,**输出:** 3
,**解释:** 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 
[https://leetcode-cn.com/problems/decode-ways/description/]
#+end_source

**** 解法 1

*状态定义*

dp[i] 0~i-1构成的字符串有多少种可能

*状态转移方程*

ddn<= 26:           dp[i] = dp[i - 2] + dp[i - 1]

ddn> 26 || ddn< 10: dp[i] = dp[i - 1]

curr == 0:          dp[i] = dp[i - 2]


#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 1/,/^}/{/\@solution dp 1/!p}' solutions/91.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int numDecodings(String s) {
        char[] digits = s.toCharArray();
        int len = digits.length;
        if (digits[0] == '0') return 0;
        int[] dp = new int[len + 1];
        dp[0] = dp[1] = 1;
        for (int i = 1; i < len; i ++) {
            if (digits[i] == '0') {
                if (digits[i - 1] != '1' && digits[i - 1] != '2') return 0;
                dp[i + 1] = dp[i - 1];
            } else if (digits[i - 1] == '1' || digits[i - 1] == '2' && digits[i] <= '6')
                dp[i + 1] = dp[i] + dp[i - 1];
            else
                dp[i + 1] = dp[i];
        }
        return dp[len];
    }
}
#+end_source

**** 解法 2 

压缩解法 1 的数组

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 2/,/^}/{/\@solution dp 2/!p}' solutions/91.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int numDecodings(String s) {
        char[] digits = s.toCharArray();
        if (digits[0] == '0') return 0;
        int prev = 1, curr = 1;
        for (int i = 1; i < digits.length; i ++) {
            int _curr = curr;
            if (digits[i] == '0') {
                if (digits[i - 1] != '1' && digits[i - 1] != '2') return 0;
                curr = prev;
            } else if (digits[i - 1] == '1' || digits[i - 1] == '2' && digits[i] <= '6')
                curr = curr + prev;
            prev = _curr;
        }
        return curr;
    }
}
#+end_source

** 最长子序列相关的动态规划

*** 300 最长上升子序列的长度

#+begin_src sh :results output :wrap source markdown
cat problems/300.*.md
#+end_src

**** 解法

*状态定义*

dp[i] 0~i个数字的最长子序列长度

*状态转移方程*

dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp/,/^}/{/\@solution dp/!p}' solutions/300.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len < 2) return len;
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        int res = 0;
        for (int i = 0; i < len; i ++) {
            for (int j = 0; j < i; j ++) 
                if (nums[j] < nums[i]) 
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
#+end_source

*** 32 最长有效括号

#+begin_src sh :results output :wrap source markdown
cat problems/32.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

,**示例 1:**

,**输入:** "(()"
,**输出:** 2
,**解释:** 最长有效括号子串为 `"()"`

,**示例 2:**

,**输入:** "`)()())`"
,**输出:** 4
,**解释:** 最长有效括号子串为 `"()()"` 
[https://leetcode-cn.com/problems/longest-valid-parentheses/description/]
#+end_source

**** 解法

*状态定义*

dp[i] 0~i之间的最长有效括号

*状态转移方程*

#+begin_example
s  ) ) ( ( ( ) ( ) ) ) (  )  )
i  0 1 2 3 4 5 6 7 8 9 10 11 12
dp 0 0 0 0 0 2 0 4 6 8 0  10 0
dp[i] == ')' 时才计算有效括号
prev = i - 1;
if (prev == '(') dp[i] = dp[prev-1] + 2; 对应dp[7] = dp[5] + 2
open = i - dp[prev] - 1;
if (prev == ')' && open == '(') dp[i] = dp[open-1] + dp[prev] + 2; 对应dp[8] = dp[3] + dp[7] + 2
#+end_example


#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp/,/^}/{/\@solution dp/!p}' solutions/32.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int longestValidParentheses(String s) {
        int len = s.length(), res = 0;
        char[] parenthese = new char[len + 2];
        parenthese[0] = parenthese[1] = ')';
        System.arraycopy(s.toCharArray(), 0, parenthese, 2, len);
        int[] dp = new int[len + 2];
        for (int i = 2; i < len + 2; i ++) {
            if (parenthese[i] == '(') continue;
            int prev = i - 1, open = i - dp[prev] - 1;
            if (parenthese[prev] == '(')
                dp[i] = dp[prev - 1] + 2;
            else if (parenthese[open] == '(')
                dp[i] = dp[open - 1] + dp[prev] + 2;
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
#+end_source

** 求最少步数的动态规划
*** 818 赛车，正反方向加速度

#+begin_src sh :results output :wrap source markdown
cat problems/818.*.md
#+end_src

**** 解法

*状态定义*

dp[i] 到达位置i需要的步数

*状态转移方程*

a为一个方向，r为a的反方向
[a] = [0]
[aa] = [0,1]
[aaa] = [0,1,3]
[aaaa] = [0,1,3,7]
aVal = (1 << aPow) - 1
rVal = (1 << rPow) - 1
if (i ==  aVal)_i为2的幂-1_
dp[i] = aPow _dp[i]为幂次_
if (i > aVal)
dp[i] = aPow + dp[i - aVal] + 1 _1为转身消耗的步数_
if (i < aVal)
dp[i]= aPow + 1 + rPow + 1 + dp[i - aVal + rVal]

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp 1/,/^}/{/\@solution dp 1/!p}' solutions/818.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int racecar(int target) {
        int[] dp = new int[target + 1];
        for (int i = 1; i <= target; i ++) {
            dp[i] = Integer.MAX_VALUE;
            for (int aPow = 1, aVal = 1; aVal < 2 * i; aVal = (1 << ++aPow) - 1) {
                if (aVal == i) {
                    dp[i] = aPow;
                    continue;
                }
                if (aVal > i) {
                    dp[i] = Math.min(dp[i], dp[aVal - i] + 1 + aPow);
                    continue;
                }
                // aVal < i
                for (int rPow = 0, rVal = 0; rPow < aPow; rVal = (1 << ++rPow) - 1) {
                    dp[i] = Math.min(dp[i], dp[i + rVal - aVal] + 1 + aPow + 1 + rPow);
                }
            }
        }
        return dp[target];
    }
}
#+end_source

** other
*** 42 接雨水

#+begin_src sh :results output :wrap source markdown
cat problems/42.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定 _n_ 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

上面是由数组 \[0,1,0,2,1,0,1,3,2,1,2,1\] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

,**示例:**

,**输入:** \[0,1,0,2,1,0,1,3,2,1,2,1\]
,**输出:** 6 
[https://leetcode-cn.com/problems/trapping-rain-water/description/]
#+end_source

**** 解法
*状态定义*
left[i] 位置i左侧最高
right[i] 位置i右侧最高

*状态转移方程*
left[i] = Math.max(height[i], left[i - 1])
right[i] = Math.max(height[i], right[i + 1])
res += Math.min(left[i], right[i]) - height[i];

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dp/,/^}/{/\@solution dp/!p}' solutions/42.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int trap(int[] height) {
        int res = 0, len = height.length;
        if (len == 0) return 0;
        int[] left = new int[len],  right = new int[len];
        left[0] = height[0];
        right[len - 1] = height[len - 1];
        for (int i = 1; i < len; i ++) 
            left[i] = Math.max(left[i - 1], height[i]);
        for (int i = len - 2; i >= 0; i --) 
            right[i] = Math.max(right[i + 1], height[i]);
        for (int i = 0; i < len; i ++) 
            res += Math.min(left[i], right[i]) - height[i];
        return res;
    }
}
#+end_source

*** TODO 5

* 利用栈
** 括号匹配
*** 20 有效的括号
#+begin_src sh :results output :wrap source markdown
cat problems/20.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。
2.  左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

,**示例 1:**

,**输入:** "()"
,**输出:** true

,**示例 2:**

,**输入:** "()\[\]{}"
,**输出:** true

,**示例 3:**

,**输入:** "(\]"
,**输出:** false

,**示例 4:**

,**输入:** "(\[)\]"
,**输出:** false

,**示例 5:**

,**输入:** "{\[\]}"
,**输出:** true 
[https://leetcode-cn.com/problems/valid-parentheses/description/]
#+end_source

**** 解法
#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution stack/,/^}/{/\@solution stack/!p}' solutions/20.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<Character, Character>(){{
            put('(', ')');
            put('[', ']');
            put('{', '}');
        }};
        Stack<Character> stack = new Stack<>();
        for (Character c : s.toCharArray()) {
            if (map.containsKey(c))
                stack.push(c);
            else if (stack.empty() || map.get(stack.pop()) != c)
                return false;
        }
        return stack.empty();
    }
}
#+end_source

*** 32 最长的有效括号
#+begin_src sh :results output :wrap source markdown
cat problems/32.*.md
#+end_src

**** 解法
#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution stack/,/^}/{/\@solution stack/!p}' solutions/32.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int res = 0, i = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.empty()) 
                    stack.push(i);
                else
                    res = Math.max(res, i - stack.peek());
            }
            i ++;
        }
        return res;
    }
}
#+end_source

*** 1111 有效括号的嵌套深度
#+begin_src sh :results output :wrap source markdown
cat problems/1111.*.md
#+end_src

**** 解法 1
#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution stack 1/,/^}/{/\@solution stack 1/!p}' solutions/1111.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int[] maxDepthAfterSplit(String seq) {
        int[] res = new int[seq.length()];
        Stack<Integer> stack = new Stack<>();
        int i = 0;
        for (char c : seq.toCharArray()) {
            if (c == '(') {
                stack.push(i);
                res[i++] = stack.size() & 1;
            } else if (c == ')') {
                res[i++] = stack.size() & 1;
                stack.pop();
            }
        }
        return res;
    }
}
#+end_source

**** 解法 2 
并不需要实际的stack，只需要变量depth模似stack.depth()就好了。
#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution stack 2/,/^}/{/\@solution stack 2/!p}' solutions/1111.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int[] maxDepthAfterSplit(String seq) {
        int[] res = new int[seq.length()];
        int depth = 0, i = 0;
        for (char c : seq.toCharArray()) {
            if (c == '(') {
                depth ++;
                res[i ++] = depth & 1;
            } else if (c == ')') {
                res[i ++] = depth & 1;                
                depth --;
            }
        }
        return res;
    }
}
#+end_source

** 单调递增栈
*** 42 柱状图里接雨水
#+begin_src sh :results output :wrap source markdown
cat problems/42.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定 _n_ 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

上面是由数组 \[0,1,0,2,1,0,1,3,2,1,2,1\] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

,**示例:**

,**输入:** \[0,1,0,2,1,0,1,3,2,1,2,1\]
,**输出:** 6 
[https://leetcode-cn.com/problems/trapping-rain-water/description/]
#+end_source

**** 解法
#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution stack/,/^}/{/\@solution stack/!p}' solutions/42.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int trap(int[] height) {
        if (height.length == 0) return 0;
        Stack<Integer> stack = new Stack<>();
        int res = 0;
        for (int i = 0; i < height.length; i ++) {
            while (!stack.empty() && height[i] > height[stack.peek()]) {
                int concave = height[stack.pop()];
                if (stack.empty()) break;
                int dist = i - stack.peek() - 1;
                int subPeak = Math.min(height[stack.peek()], height[i]);
                res += (subPeak - concave) * dist;
            }
            stack.push(i);
        }
        return res;
    }
}
#+end_source

*** 84 柱状图的最大矩形
#+begin_src sh :results output :wrap source markdown
cat problems/84.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

,**示例:**

,**输入:** \[2,1,5,6,2,3\]
,**输出:** 10 
[https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/]
#+end_source

**** 解法
#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution stack 1/,/^}/{/\@solution stack 1/!p}' solutions/84.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxArea = 0;
        for (int i = 0; i < heights.length; i ++) {
            while (stack.peek() != -1 && heights[i] <= heights[stack.peek()]) 
                maxArea = Math.max(maxArea, heights[stack.pop()] * (i - stack.peek() - 1));
            
            stack.push(i);
        }

        while (stack.peek() != -1) {
            maxArea = Math.max(maxArea, heights[stack.pop()] * (heights.length - stack.peek() - 1));
        }
        return maxArea;
    }
}
#+end_source

* TODO 利用双端队列
*** 151
* TODO 滑动窗口
https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/
*** 76 
*** 438
*** 3

* 分治
** 二分法
*** 

* Disjoint-set
** 200.岛屿数量
#+begin_src sh :results output :wrap source markdown
cat problems/200.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

,**示例 1:**

,**输入:**
11110
11010
11000
00000

,**输出:** 1

,**示例 2:**

,**输入:**
11000
11000
00100
00011

,**输出:** 3
[https://leetcode-cn.com/problems/number-of-islands/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution disjoint\-set/,/^}/{/\@solution disjoint\-set/!p}' solutions/200.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int numIslands(char[][] grid) {
        int rl = grid.length, cl = grid[0].length, waterCount = 0;
        UnionFind uf = new UnionFind(rl * cl);
        for (int r = 0; r < rl; r ++) {
            for (int c = 0; c < cl; c ++) {
                if (grid[r][c] == '1') {
                    if (r > 0 && grid[r - 1][c] == '1')
                        uf.union(r * cl + c, (r - 1) * cl +c);
                    else if (c > 0 && grid[r][c - 1] == '1')
                        uf.union(r * cl + c, r * cl + c - 1);
                } else {
                    waterCount ++;
                }
            }
        }
        return uf.count - waterCount;
    }
    class UnionFind {
        int count = 0;
        int[] parent;
        public UnionFind(int n) {
            count = n;
            parent = new int[n];
            for (int i = 0; i < n; i ++)
                parent[i] = i;
        }
        public int find(int p) {
            while (p != parent[p]) {
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
        public void union(int p, int q) {
            if (p == q) return;
            int rp = find(p);
            int rq = find(q);
            if (rp == rq) return;
            parent[rp] = rq;
            count --;
        }
    }
}
#+end_source

** 547 朋友圈
#+begin_src sh :results output :wrap source markdown
cat problems/547.*.md
#+end_src

#+begin_src sh :results output :wrap source java
  sed -n '/\@solution disjoint\-set/,/^}/{/\@solution disjoint\-set/!p}'
  solutions/547.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int findCircleNum(int[][] M) {
        if (M == null || M.length == 0) return 0;
        int len = M.length;
        UnionFind uf = new UnionFind(len);
        for (int i = 0; i < len; i ++) {
            for (int j = 0; j < len; j ++) {
                if (M[i][j] == 1)
                    uf.union(i, j);
            }
        }
        return uf.count;
    }
    class UnionFind {
        int count = 0;
        int[] parent;
        public UnionFind(int n) {
            count = n;
            parent = new int[n];
            for (int i = 0; i < n; i ++)
                parent[i] = i;
        }
        public int find(int p) {
            while (p != parent[p]) {
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
        public void union(int p, int q) {
            int rp = find(p);
            int rq = find(q);
            if (rp == rq) return;
            parent[rp] = rq;
            count --;
        }
    }
}
#+end_source

** 130 被围绕的区域
#+begin_src sh :results output :wrap source markdown
cat problems/130.*.md
#+end_src

#+begin_src sh :results output :wrap source java
  sed -n '/\@solution disjoint\-set/,/^}/{/\@solution disjoint\-set/!p}' solutions/130.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public void solve(char[][] board) {
        if (board == null || board.length == 0) return;
        int rl = board.length, cl = board[0].length;
        UnionFind uf = new UnionFind(rl * cl + 1);
        int O = rl * cl;
        for (int r = 0; r < rl; r ++) {
            for (int c = 0; c < cl; c ++) {
                if (board[r][c] == 'X') continue;
                if (r == 0 || c == 0 || r == rl - 1 || c == cl - 1) {
                    uf.union(r * cl + c, O);
                    continue;
                }
                if (board[r - 1][c] == 'O')
                    uf.union(r * cl + c, (r - 1) * cl + c);
                if (board[r + 1][c] == 'O')
                    uf.union(r * cl + c, (r + 1) * cl + c);
                if (board[r][c - 1] == 'O')
                    uf.union(r * cl + c, r * cl + c - 1);
                if (board[r][c + 1] == 'O')
                    uf.union(r * cl + c, r * cl + c + 1);
            }
        }
        for (int r = 0; r < rl; r ++) {
            for (int c = 0; c < cl; c ++) {
                if (board[r][c] == 'X') continue;
                if (!uf.isConnected(r * cl + c, O))
                    board[r][c] = 'X';
            }
        }
    }
    class UnionFind {
        int count = 0;
        int[] parent;
        public UnionFind(int n) {
            count = n;
            parent = new int[n];
            for (int i = 0; i < n; i ++) {
                parent[i] = i;
            }
        }
        public int find(int p) {
            while (p != parent[p]) {
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
        public void union(int p, int q) {
            if (p == q) return;
            int rp = find(p);
            int rq = find(q);
            if (rp == rq) return;
            parent[rp] = rq;
            count --;
        }
        public boolean isConnected(int p, int q) {
            return find(p) == find(q);
        }
    }
}
#+end_source


* BFS
有一种替换set(queue)的方法、一种poll queue的方法
** 1162 地图分析
200 岛屿数量
693 岛屿的最大面积
#+begin_src shell :results output :wrap source java
gsed -n '/\@solution bfs/,/^}/{/\@solution bfs/!p}' solutions/1162.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int maxDistance(int[][] grid) {
        Queue<Integer> queue = new LinkedList<>();
        int rl = grid.length, cl = grid[0].length;
        for (int r = 0; r < rl; r ++) 
            for (int c = 0; c < cl; c ++) 
                if (grid[r][c] == 1) {
                    queue.offer(r);
                    queue.offer(c);
                }
        if (queue.size() == 0 || queue.size() == rl * cl * 2)
            return -1;
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        int _x = 0, _y = 0;
        while (!queue.isEmpty()) {
            _x = queue.poll();
            _y = queue.poll();
            for (int i = 0; i < 4; i ++){
                int x = _x + dx[i];
                int y = _y + dy[i];
                if (x < 0 || y < 0 || x == rl || y == cl) continue;
                if (grid[x][y] != 0) continue;
                grid[x][y] = grid[_x][_y] + 1;
                queue.offer(x);
                queue.offer(y);
            }
        }
        return grid[_x][_y] - 1;
    }
}
#+end_source

** 310 最小高度树
#+begin_src sh :results output :wrap source markdown
cat problems/127.*.md
#+end_src

#+begin_src sh :results output :wrap source java
gsed -n '/\@solution bfs/,/^}/{/\@solution bfs/!p}' solutions/310.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        if (n <= 1) return Arrays.asList(0);
        if (n == 2) return Arrays.asList(0, 1);
        List<Integer> res = new ArrayList<>();
        int[] indegree = new int [n];
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; i ++)
            tree.add(new ArrayList<>());
        for (int[] e : edges) {
            indegree[e[0]] ++;
            indegree[e[1]] ++;
            tree.get(e[0]).add(e[1]);
            tree.get(e[1]).add(e[0]);
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i ++) 
            if (indegree[i] == 1)
                queue.offer(i);
        
        while(!queue.isEmpty()) {
            int size = queue.size();
            res = new ArrayList<>();
            for (int i = 0; i < size; i ++) {
                int leaf = queue.poll();
                res.add(leaf);
                for (int node : tree.get(leaf)) 
                    if (--indegree[node] == 1) 
                        queue.offer(node);
            }
        }
        return res;
    }
}
#+end_source

* Two-End BFS
** 127 单词接龙
#+begin_src sh :results output :wrap source markdown
cat problems/127.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定两个单词（_beginWord_ 和 _endWord_）和一个字典，找到从 _beginWord_ 到 _endWord_ 的最短转换序列的长度。转换需遵循如下规则：

1.  每次转换只能改变一个字母。
2.  转换过程中的中间单词必须是字典中的单词。

,**说明:**

,*   如果不存在这样的转换序列，返回 0。
,*   所有单词具有相同的长度。
,*   所有单词只由小写字母组成。
,*   字典中不存在重复的单词。
,*   你可以假设 _beginWord_ 和 _endWord_ 是非空的，且二者不相同。

,**示例 1:**

,**输入:**
beginWord = "hit",
endWord = "cog",
wordList = \["hot","dot","dog","lot","log","cog"\]

,**输出:** 5

,**解释:** 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。

,**示例 2:**

,**输入:**
beginWord = "hit"
endWord = "cog"
wordList = \["hot","dot","dog","lot","log"\]

,**输出:** 0

,**解释:** _endWord_ "cog" 不在字典中，所以无法进行转换。
[https://leetcode-cn.com/problems/word-ladder/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution two\-end bfs/,/^}/{/\@solution two\-end bfs/!p}' solutions/127.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> dict = new HashSet<>(wordList), temp = new HashSet<>();
        Set<String> front = new HashSet<>(), back = new HashSet<>();
        if (!dict.contains(endWord)) return 0;
        int step = 1;
        front.add(beginWord);
        back.add(endWord);
        dict.remove(beginWord);
        while(!front.isEmpty() && !back.isEmpty()) {
            if (front.size() > back.size()) { // todo
                temp = front;
                front = back;
                back = temp;
            }
            temp = new HashSet<>();
            for(String word : front) {
                for(int i = beginWord.length() - 1; i >= 0 ; i --) {
                    char[] letters = word.toCharArray();
                    for (char alphabet = 'a'; alphabet <= 'z'; alphabet ++) {
                        if (letters[i] == alphabet) continue;
                        letters[i] = alphabet;
                        String target = String.valueOf(letters);
                        if (back.contains(target)) return step + 1;
                        if (dict.contains(target)) {
                            temp.add(target);
                            dict.remove(target);
                        }
                    }
                }
            }
            front = temp;
            step ++;
        }
        return 0;
    }
}
#+end_source


** 433 最小基因变化
#+begin_src sh :results output :wrap source markdown
cat problems/433.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 `"A"`, `"C"`, `"G"`, `"T"`中的任意一个。

假设我们要调查一个基因序列的变化。**一次**基因变化意味着这个基因序列中的**一个**字符发生了变化。

例如，基因序列由`"AACCGGTT"` 变化至 `"AACCGGTA"` 即发生了一次基因变化。

与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。

现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。

,**注意:**

1.  起始基因序列默认是合法的，但是它并不一定会出现在基因库中。
2.  所有的目标基因序列必须是合法的。
3.  假定起始基因序列与目标基因序列是不一样的。

,**示例 1:**

start: "AACCGGTT"
end:   "AACCGGTA"
bank: \["AACCGGTA"\]

返回值: 1

,**示例 2:**

start: "AACCGGTT"
end:   "AAACGGTA"
bank: \["AACCGGTA", "AACCGCTA", "AAACGGTA"\]

返回值: 2

,**示例 3:**

start: "AAAAACCC"
end:   "AACCCCCC"
bank: \["AAAACCCC", "AAACCCCC", "AACCCCCC"\]

返回值: 3
[https://leetcode-cn.com/problems/minimum-genetic-mutation/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution two\-end bfs/,/^}/{/\@solution two\-end bfs/!p}' solutions/433.*.java
#+end_src

#+RESULTS:
#+begin_source java
// todo hashset is better than linkedlist
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        Set<String> dict = new HashSet<>(Arrays.asList(bank)), temp = new HashSet<>();
        Set<String> front = new HashSet<>(), back = new HashSet<>();
        if (!dict.contains(end)) return -1;
        char[] nucleobases = {'A', 'C', 'G', 'T'};
        int step = 0;
        front.add(start);
        back.add(end);
        dict.remove(start);
        while (!front.isEmpty() && !back.isEmpty()) {
            if (front.size() > back.size()) {
                temp = front;
                front = back;
                back = temp;
            }
            temp = new HashSet<>();
            for (String sequence : front) {
                for (int i = sequence.length() - 1; i >= 0; i --) {
                    char[] genes = sequence.toCharArray();
                    for (char base : nucleobases) {
                        if (genes[i] == base) continue;
                        genes[i] = base;
                        String mutation = String.valueOf(genes);
                        if (back.contains(mutation)) return step + 1;
                        if (dict.contains(mutation)) {
                            dict.remove(mutation);
                            temp.add(mutation);
                        }

                    }
                }
            }
            step ++;
            front = temp;
        }
        return -1;
    }
}
#+end_source


* A* (Heuristic Search)
两种实现方式:
1. inner class implements Comparable
2. comparator to priority queue

** 1091 二进制矩阵的最短路径
#+begin_src sh :results output :wrap source markdown
cat problems/1091.*.md
#+end_src

#+begin_src sh :results output :wrap source java
sed -n '/\@solution a\*/,/^}/{/\@solution a\*/!p}' solutions/1091.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    int n;
    public int shortestPathBinaryMatrix(int[][] grid) {
        n = grid.length;
        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
        if (n == 1) return 1;
        int[][] dir = {
            {-1, 0}, {1, 0}, {0, -1}, {0, 1},
            {-1, 1}, {-1, -1}, {1, -1}, {1, 1}
        };
        Node start = new Node(0, 0, grid[0][0] = 1);
        Queue<Node> queue = new PriorityQueue<>();
        queue.offer(start);
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            int step = grid[node.x][node.y];
            for (int[] d : dir) {
                int x = node.x + d[0];
                int y = node.y + d[1];
                if (x == n - 1 && y == n - 1) return step + 1;
                if (x < 0 || x >= n || y < 0 || y >= n) continue;
                if (grid[x][y] != 0 && grid[x][y] <= step + 1) continue;
                Node next = new Node(x, y, grid[x][y] = step + 1);
                queue.offer(next);
            }
        }
        return -1;
    }

    class Node implements Comparable<Node> {
        int x;
        int y;
        int f;

        public Node(int x, int y, int step) {
            this.x = x;
            this.y = y;
            int distance = Math.max(n - 1 - x, n - 1 - y);
            this.f = distance + step;
        }

        @Override
        public int compareTo(Node o) {
            return this.f - o.f;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Node)) return false;
            Node node = (Node) o;
            return x == node.x && y == node.y;
        }

        @Override
        public int hashCode() {
            return Integer.hashCode(x * n + y);
        }
    }
}
#+end_source


** 773
#+begin_src sh :results output :wrap source markda
own
cat problems/773.*.md
#+end_src

#+begin_src sh :results output :wrap source java
sed -n '/\@solution a\*/,/^}/{/\@solution a\*/!p}' solutions/773.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int slidingPuzzle(int[][] board) {
        Box box = new Box(board);
        int[] endBoard = {1, 2, 3, 4, 5, 0};
        int[] wrongBoard = {1, 2, 3, 5, 4, 0};
        if (Arrays.equals(box.board, endBoard)) return 0;
        if (Arrays.equals(box.board, wrongBoard)) return -1;
        HashSet<Box> visited = new HashSet<>();
        PriorityQueue<Box> queue = new PriorityQueue<>();
        int[][] dir = {
            {1, 3}, {0, 2, 4}, {1, 5},
            {0, 4}, {1, 3, 5}, {2, 4}
        };
        queue.offer(box);
        visited.add(box);
        while (!queue.isEmpty()) {
            box = queue.poll();
            for (int nextZero : dir[box.zero]) {
                int[] nextBoard = Arrays.copyOf(box.board, 6);
                nextBoard[box.zero] = nextBoard[nextZero];
                nextBoard[nextZero] = 0;
                if (Arrays.equals(nextBoard, endBoard)) return box.step + 1;
                if (Arrays.equals(nextBoard, wrongBoard)) return -1;
                Box next = new Box(nextBoard, nextZero, box.step + 1);
                if (visited.contains(next)) continue;
                queue.offer(next);
                visited.add(next);
            }
        }
        return -1;
    }

    static class Box implements Comparable<Box> {
        int[] board;
        int zero;
        int step; // g(n)
        int distance; // h(n)
        int f; // f(n) = g(n) + h(n)

        public Box(int[][] board) {
            this.board = new int[6];
            for (int i = 0; i < 6; i++) {
                this.board[i] = board[i / 3][i % 3];
                if (this.board[i] == 0) this.zero = i;
            }
            this.step = 0;
            this.distance = calcDistance();
            this.f = this.step + this.distance;
        }

        public Box(int[] board, int zero, int step) {
            this.board = board;
            this.zero = zero;
            this.step = step;
            this.distance = calcDistance();
            this.f = this.step + this.distance;
        }

        private int calcDistance() {
            int distance = 0;
            for (int i = 0; i < 6; i++) {
                int v = board[i] - 1; // target idx of board;
                distance += Math.abs(v / 3 - i / 3) + Math.abs(v % 3 - i % 3);// row + col
            }
            return distance;
        }

        @Override
        public int compareTo(Box box) {
            return this.f - box.f;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Box)) return false;
            Box box = (Box) o;
            return zero == box.zero && Arrays.equals(board, box.board);
        }

        @Override
        public int hashCode() {
            int result = Objects.hash(zero);
            result = 31 * result + Arrays.hashCode(board);
            return result;
        }
    }
}
#+end_source

* DFS
** backtracking
*** 70 爬楼梯
#+begin_src sh :results output :wrap source markdown
cat problems/70.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

,**注意：**给定 _n_ 是一个正整数。

,**示例 1：**

,**输入：** 2
,**输出：** 2
,**解释：** 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

,**示例 2：**

,**输入：** 3
,**输出：** 3
,**解释：** 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
[https://leetcode-cn.com/problems/climbing-stairs/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution backtracking 1/,/^}/{/\@solution backtracking 1/!p}' solutions/70.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    int[] sol = new int[100];
    public int climbStairs(int i) {
        sol[1] = 1;
        sol[2] = 2;
        if (i <= 2) return sol[i];
        if (sol[i] != 0) return sol[i];
        sol[i] = climbStairs(i - 1) + climbStairs(i - 2);
        return sol[i];
    }
}
#+end_source

#+begin_src sh :results output :wrap source java
sed -n 's/\/\/\s//; /\@solution backtracking 2/,/^}/{/\@solution backtracking 2/!p}' solutions/70.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    // an int is a primitive type and cannot be null
    public Integer[] sol = new Integer[100];
    public int climbStairs(int i) {
        sol[1] = 1;
        sol[2] = 2;
        if (i <= 2) return sol[i];
        if (sol[i - 1] == null) sol[i - 1] = climbStairs(i - 1);
        if (sol[i - 2] == null) sol[i - 2] = climbStairs(i - 2);
        return sol[i-1] + sol[i-2];
    }
}
#+end_source

*** 22 括号生成
#+begin_src sh :results output :wrap source markdown
cat problems/22.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给出 _n_ 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 _n_ \= 3，生成结果为：

\[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
\]
[https://leetcode-cn.com/problems/generate-parentheses/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution backtracking/,/^}/{/\@solution backtracking/!p}' solutions/22.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        dfs(n, "", 0, 0);
        return res;
    }
    void dfs(int n, String str, int l, int r) {
        if (l == n && r == n) {
            res.add(str);
            return;
        }
        if (l < n)
            dfs(n, str + "(", l + 1, r);
        if (r < l)
            dfs(n, str + ")", l, r + 1);
    }
}
#+end_source

*** 37 解数独
#+begin_src sh :results output :wrap source markdown
cat problems/37.*.md
#+end_src

#+begin_src sh :results output :wrap source java
sed -n '/\@solution backtracking/,/^}/{/\@solution backtracking/!p}' solutions/37.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public void solveSudoku(char[][] board) {
        dfs(board, 0);
    }

    boolean dfs (char[][] board, int pos) {
        if (pos == 81) return true;

        int r = pos / 9, c = pos % 9;
        if (board[r][c] != '.') return dfs(board, pos + 1);
        char digit = '0';
        for (boolean valid: getValid(board, r, c)) {
            digit ++;
            if (!valid) continue;
            board[r][c] = digit;
            if (dfs(board, pos + 1)) return true;
        }

        board[r][c] = '.';
        return false;
    }
    boolean[] getValids(char[][] board, int r, int c) {
        boolean[] valids = new boolean[9];
        Arrays.fill(valids, true);
        for (int i = 0; i < 9; i ++) {
            char[] toValid = {
                board[r][i], // current row
                board[i][c], // current column
                board[r/3*3+i/3][c/3*3+i%3] // current block
            };
            // if any toValid has digit, then false.
            for (char tv: toValid)
                if (tv != '.')
                    valids[tv - '1'] = false;
        }
        return valid;
    }
}
#+end_source

*** 51 n皇后
#+begin_src sh :results output :wrap source markdown
cat problems/51.*.md
#+end_src

#+begin_src sh :results output :wrap source java
sed -n '/\@solution backtracking/,/^}/{/\@solution backtracking/!p}' solutions/51.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    int rl, cl;
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        rl = cl = n;
        dfs(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());
        return res;
    }
    void dfs(List<Integer> queenInRows, List<Integer> lowerRight, List<Integer> lowerLeft) {
        int r = queenInRows.size();
        if (r == rl) {
            List<String> solution = new ArrayList<>();
            for (int idx: queenInRows) {
                solution.add(".".repeat(idx) + "Q" + ".".repeat(rl - 1 - idx));
            }
            res.add(solution);
            return;
        }
        for (int c = 0; c < cl; c ++) {
            if (queenInRows.contains(c)) continue;
            // if x1 - y1 = x2 - y2, [x1, y1] and [x2, y2] are in same lowerright line;
            if (lowerRight.contains(r - c)) continue;
            // if x1 + y1 = x2 + y2, [x1, y1] and [x2, y2] are in same lowerleft line;
            if (lowerLeft.contains(r + c)) continue;
            queenInRows.add(c);
            lowerRight.add(r - c);
            lowerLeft.add(r + c);
            dfs(new ArrayList<>(queenInRows), new ArrayList<>(lowerRight), new ArrayList<>(lowerLeft));
            int lastIdx = r;
            queenInRows.remove(lastIdx);
            lowerRight.remove(lastIdx);
            lowerLeft.remove(lastIdx);
        }
    }
}
#+end_source

* Trie
** 212 单词搜索
#+begin_src sh :results output :wrap source markdown
cat problems/212.*.md
#+end_src

#+begin_src shell :results output :wrap source java
sed -n '/\@solution trie/,/^}/{/\@solution trie/!p}' solutions/212.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    int rl, cl;
    Set<String> res;
    boolean[][] visited;
    public List<String> findWords(char[][] board, String[] words) {
        rl = board.length;
        cl = board[0].length;
        res = new HashSet<>();
        Trie trie = new Trie();

        for (String s: words)
            trie.insert(s);

        for (int r = 0; r < rl; r ++) {
            for (int c = 0; c < cl; c ++) {
                dfs(board, r, c, trie.root);
            }
        }
        return new ArrayList<String>(res);
    }

    void dfs(char[][] board, int r, int c, TrieNode node) {
        if (r < 0 || c < 0 || r >= rl || c >= cl || board[r][c] == '\0')
            return;
        node = node.children[board[r][c] - 'a'];
        if (node == null)
            return;
        if (node.isEnd)
             res.add(node.val);

        char tmp = board[r][c];
        board[r][c] = '\0';
        dfs(board, r + 1, c, node);
        dfs(board, r - 1, c, node);
        dfs(board, r, c + 1, node);
        dfs(board, r, c - 1, node);
        board[r][c] = tmp;
    }

    class Trie {
        public TrieNode root = new TrieNode();
        public void insert (String str) {
            TrieNode node = root;
            for(char c : str.toCharArray()) {
                if (node.children[c - 'a'] == null)
                    node.children[c - 'a'] = new TrieNode();
                node = node.children[c - 'a'];
            }
            node.isEnd = true;
            node.val = str;
        }
    }
    class TrieNode {
        public String val;
        public TrieNode[] children;
        public boolean isEnd = false;
        TrieNode() {
            children = new TrieNode[26];
        }
    }
}
#+end_source

** 820 单词的压缩编码
#+begin_src sh :results output :wrap source markdown
cat problems/820.*.md
#+end_src

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//; /\@solution trie/,/^}/{/\@solution trie/!p}' solutions/820.*.java
#+end_src

** TODO 14
* bit
** TODO 191 
** TODO 231 2的幂

* 排序
** algorithms
*** insertion sort
#+begin_src shell :results output :wrap source java
gsed -n 's/^    //; /^public void insertion(/,/^\}/p' src/sort.java
#+end_src

#+RESULTS:
#+begin_source java
public void insertion(int[] arr) {
    for (int i = 0; i < arr.length; i ++) {
        for (int j = i + 1; j > 0; j --) {
            if (arr[j - 1] <= arr[j]) break;
            swap(arr, j, j -1);
        }
    }
}
#+end_source

*** shell sort
#+begin_src shell :results output :wrap source java
gsed -n 's/^    //; /^public void shell(/,/^\}/p' src/sort.java
#+end_src

#+RESULTS:
#+begin_source java
public void shell(int[] arr) {
    int len = arr.length;
    for (int gap = len / 2; gap > 0; gap /= 2) {
        for (int i = 0; (i + gap) < len; i ++) {
            for (int j = 0; j + gap < len; j += gap) {
                if (arr[j] > arr[j + gap]) {
                    int temp = arr[j];
                    arr[j] = arr[j+ gap];
                    arr[j+ gap] = temp;
                }
            }
        }
    }
}
#+end_source



#+begin_src shell :results output :wrap source java
gsed -n 's/^    //; /^public void shell2(/,/^\}/p' src/sort.java
#+end_src

#+RESULTS:
#+begin_source java
public void shell2(int[] arr) {
    int len = arr.length;
    int gap = 1;
    while (gap < len / 3)
        gap = gap * 3 + 1;

    for (; gap > 0; gap /= 3) {
        for (int i = gap; i < len; i ++) {
            int temp = arr[i];
            for (int j = i - gap; j >= 0 && arr[j] > temp; j -= gap)
                arr[j + gap] = arr[j];
            arr[j + gap] = temp;
        }
    }
}
#+end_source


*** selection
#+begin_src shell :results output :wrap source java
gsed -n 's/^    //; /^public void selection(/,/^\}/p' src/sort.java
#+end_src

#+RESULTS:
#+begin_source java
public void selection(int[] arr) {
    for (int i = 0, i < arr.length - 1; i++) {
        int min = i;
        for (int j = i + 1; j < arr.length; j ++) {
            if (arr[j] < arr[min])
                min = j;
        }
        if (min != i) {
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}
#+end_source

*** heap
#+begin_src shell :results output :wrap source java
gsed -n 's/^    //; /^public void heap(/,/^\}/p' src/sort.java
gsed -n 's/^    //; /^private void heapify(/,/^\}/p' src/sort.java
#+end_src

#+RESULTS:
#+begin_source java
public void heap(int[] arr) {
    for (int i = arr.length - 1; i >= 0; i --) {
        heapify(arr, i + 1);
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
    }
}
private void heapify(int [] arr, int len) {
    if (arr.length <= 0 || arr.length < len) return;
    for (int parent = len / 2; parent >= 0; parent --) {
        if (parent * 2 == limit) continue;
        int left = parent * 2;
        int right = (left + 1) >= len ? left : left + 1;
        int max = arr[left] > arr[right] ? left : right;
        if (arr[max] > arr[parent]) {
            int temp = arr[parent];
            arr[parent] = arr[max];
            arr[max] = temp;
        }
    }
}
#+end_source

*** quick 
#+begin_src shell :results output :wrap source java
gsed -n 's/^    //; /^public void quick(/,/^\}/p' src/sort.java
#+end_src

#+RESULTS:
#+begin_source java
public void quick(int[] arr, int start, int end) {
    if (arr.length <= 0 || start >= end) return;
    int left = start, right = end;
    int temp = arr[left];
    while (left < right) {
        while (left < right && arr[right] >= temp)
            right --;
        arr[left] = arr[right]; // @1
        while (left < right && arr[left] <= temp)
            left --;
        arr[right] = arr[left]; // @2
    }
    arr[left] = temp; // @3
    quick(arr, start, left - 1);
    quick(arr, left + 1, end);
}
#+end_source

*** bubble

** 1122 数组的相对排序
** 逆序对
*** merge-sort
   mutual exclusive & completely exhausive

*** 树状数组


* 有限状态机
Deterministic Finite Automaton
*** 8 atoi
#+begin_src sh :results output :wrap source markdown
cat problems/8.*.md
#+end_src

**** 解法

#+begin_src shell :results output :wrap source java
gsed -n 's/^\/\/\s//;/\@solution dfa/,/^}/{/\@solution dfa/!p}' solutions/8.*.java
#+end_src

#+RESULTS:
#+begin_source java
import java.util.HashMap;
class Solution {
    public int myAtoi(String str) {
        Automation dfa = new Automation();
        for (char c : str.toCharArray())
            dfa.set(c);
        return dfa.sign * (int)dfa.num;
    }
    class Automation {
        HashMap<String, String[]> table = new HashMap<>();
        String state = "start";
        int sign = 1;
        long num = 0;
        Automation() {
            table.put("start", new String[]{"start", "signed", "in_number", "end"});
            table.put("signed", new String[]{"end", "end", "in_number", "end"});
            table.put("in_number", new String[]{"end", "end", "in_number", "end"});
            table.put("end", new String[]{"end", "end", "end", "end"});
        }
        String nextState (String state, char c) {
            String[] states = table.get(state);
            if (c == ' ') return states[0];
            if (c == '+' || c == '-') return states[1];
            if (c <='9' && c >= '0') return states[2];
            return states[3];
        }
        void set(char c) {
            state = nextState(state, c);
            if (state == "signed")
                sign = c == '+' ? 1 : -1;
            if (state == "in_number") {
                num = num * 10 + (c - '0');
                if (sign > 0)
                    num = Math.min(num, (long)Integer.MAX_VALUE);
                else
                    num = Math.min(num, -(long)Integer.MIN_VALUE);
            }
        }
    }
}
#+end_source

*** TODO 393 UTF-8 编码验证
*** TODO 65 有效数字

* 类型题

** 买卖股票的最佳时机
- 121 只买卖一次

*状态定义*

*状态转移方程*

- 122 可买卖多次

*状态定义*

*状态转移方程*

- 123 最多买卖两次

*状态定义*

buy[i][j] 表示在第0~i的区间内，第j次买的最大收益 

sell[i][j] 表示在第0~i的区间内，第j次卖的最大收益 

*状态转移方程*

buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]);

sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j] + prices[i]);

- 188 最多买卖k次

*状态定义*

buy[i][j] 表示在第0~i的区间内，第j次买的最大收益 

sell[i][j] 表示在第0~i的区间内，第j次卖的最大收益

*状态转移方程*

buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]);

sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j] + prices[i]);

- 309 可买卖多次但卖出后最少要隔一天才能再买入

*状态定义*

buy[i]表示在第0~i的区间内，处于购买状态的最大收益

sell[i]表示在第0~i的区间内，处于卖出状态的最大收益

cooll[i]表示在第0~i的区间内，处于冷冻状态的最大收益

*状态转移方程*

buy[i] = Math.max(buy[i - 1], cool[i - 1] - prices[i]);

sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);

cool[i] = sell[i - 1];

- 714 可买卖多次但每次买卖含手续费

*状态定义*

buy[i]表示在第0~i的区间内，处于购买状态的最大收益

sell[i]表示在第0~i的区间内，处于卖出状态的最大收益

*状态转移方程*

buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i] - fee);

sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);

** 最大矩形
单调递增栈
*** 84 柱状图 
*** 85 二维数组
* 模板
** 递归
   #+begin_src java
   void recur(int level, int param) {
       // terminator
       if (level > maxLevel) return;
       // process current logic
       process(level, param);
       param.do();
       // drill down
       recur(level + 1, param);
       // restore current states
       param.undo();
   }
   #+end_src
** 分治
   #+begin_src java
   void divideConquer(problem) {
       // recursion terminator 
       if (problem.isEmpty()) return;

       // prepare data
       problem.do();
       Element[] subproblem = problem.splite();
       int[] subRes = new int[subproblem.length];
       // conquer subproblem;
       int i = 0;
       for (Element sub : subproblem) {
           subRes[i++] = divideConquer(sub);
       }

       // process and generate result;
       int result = processResult(subRes);
       
       // revert current level states
       problem.undo();
   }
   #+end_src
** 动态规划
   #+begin_src java
   void dp (int n) {
       int[][] dp = new int[n][n];
       for (int i = 0; i < n; i ++) 
           for (int j = 0; j < n; j ++)
               dp[i][j] = func(dp[_i][_j]);
       return dp[n - 1][n - 1];
   }
   #+end_src


